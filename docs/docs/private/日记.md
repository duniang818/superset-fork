![1719100382351](image/日记/1719100382351.png)


# 从一个git仓库提交代码到另一个git仓库

![](https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png)[Icarus426](https://blog.csdn.net/xiexiangyu92 "Icarus426")![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png)于 2017-10-31 20:01:30 发布![](https://csdnimg.cn/release/blogv2/dist/pc/img/articleReadEyes2.png)阅读量1.2w[![](https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollect2.png) **收藏** **18**]()![](https://csdnimg.cn/release/blogv2/dist/pc/img/newHeart2023Black.png)点赞数 2

**分类专栏：** [Android](https://blog.csdn.net/xiexiangyu92/category_6938243.html) [应用开发](https://blog.csdn.net/xiexiangyu92/category_7064233.html) **文章标签：** [git](https://so.csdn.net/so/search/s.do?q=git&t=all&o=vip&s=&l=&f=&viparticle=) [Android](https://so.csdn.net/so/search/s.do?q=Android&t=all&o=vip&s=&l=&f=&viparticle=)

[![](https://img-blog.csdnimg.cn/20201014180756927.png?x-oss-process=image/resize,m_fixed,h_64,w_64)Android**同时被 2 个专栏收录**![](https://csdnimg.cn/release/blogv2/dist/pc/img/newArrowDown1White.png)](https://blog.csdn.net/xiexiangyu92/category_6938243.html "Android")

50 篇文章0 订阅

[订阅专栏]()

[![](https://img-blog.csdnimg.cn/20201014180756916.png?x-oss-process=image/resize,m_fixed,h_64,w_64)应用开发](https://blog.csdn.net/xiexiangyu92/category_7064233.html "应用开发")

21 篇文章0 订阅

[订阅专栏]()

转自：https://segmentfault.com/a/1190000004326399

在实际的开发中，有可能遇到需要将A仓库的某个branch的代码独立成为一个新的仓库B。我们需要的不仅仅是这个branch的最新提交的代码，而是需要它的整个提交历史。这种需求对于git来说非常简单，主要依靠 `git remote`命令来实现。

### 把当前代码提交到另一个远程git仓库

假如仓库repo_a当前位于branch_a，要求将branch_a的整个数据（包括提交历史）全部提取出来，并建立一个新的仓库repo_b。这里假设仓库repo_b已经被建立。
`git remote add`基本语法如下。name和url是必须的。

> git remote add [-t `<branch>`] [-m `<master>`] [-f] [--[no-]tags] [--mirror=<fetch|push>] `<name>` `<url>`

1、 将仓库repo_b的URL添加到工作仓库的remote。

```

```

```ruby
git remote add origin_repo_b git@server_ip:/path/repo_b.git
```

(`origin_repo_b`:自己起的名字，只要不与现有的remote名重复即可)
(`git@server_ip:/path/repo_b.git`:repo_b的远程SSH路径)

2、将代码推送到远程repo_b。

```perl
git push origin_repo_b branch_a
```

(`origin_repo_b`:远程仓库repo_b的名字)
(`branch_a`:仓库repo_a的的branch_a分支)

3、克隆仓库repo_b，检查是否push成功。

```ruby
git clone git@server_ip:/path/repo_b.git
```

---

### 将一份相同的代码提交到多个不同的git托管服务器（多个git仓库）

方法非常相似，多使用到了命令 `git remote set-url --add [--push] <name> <newurl>`
假设在远程的git服务器上又新增了一个仓库repo_c，现在要求repo_b、repo_c提交的代码必须一致。
1、将远程repo_c配置到当前的工作的本地git仓库中

```ruby
git remote set-url --add origin_repo_b git@192.168.1.101:~/project/repo_c.git
```

这句话的意思是，将远程仓库git@192.168.1.101:~/project/repo_c.git也加入到origin_repo_b这个名字下面管理

2、将代码同时提交到远程仓库repo_b和远程仓库repo_c

```perl
git push origin_repo_b branch_a
```

# 同仓库中将一个分支合并到另外一个分支

将 a 合并到b

git chekout b

git merge a

修改分支名


在项目开发过程中，有时会涉及到 分支的重命名，那么当本地的开发分支还没有推送到远程分支的时候，会在本地进行分支的重命名：

重命名本地分支
在当前分支时
git branch -m new_branch_name
1
当不在当前分支时
git branch -m old_branch_name new_branch_name
1
如果是已经推送到远端，应该怎么做呢？

重命名远端分支（假设是在当前分支，并且远端分支与本地分支名是一致的）
重命名本地分支
git branch -m new_branch_name
1
删除远程分支
git push --delete origin old_branch_name
1
上传新命名的本地分支
git push origin new_branch_name
1
关联修改后的本地分支与远程分支
git branch --set-upstream-to origin/new_branch_name


————————————————

在本地建立新分支并切换到新分支 dev

PS D:\ss-dev\superset> git checkout -b dev
Switched to a new branch 'dev'

将本地master分支合并到dev
PS D:\ss-dev\superset> git merge master
Already up to date.

推送本地分支并新建远程分支dev

PS D:\ss-dev\superset> git push superset-fork dev

# 在本地将a仓库branch-a合并到b仓库branch-b

其实这个需求可以理解为是在b仓库中备份，这可以直接在当前仓库建立新的分支实现

如果非要实现这样的需求

# 分支只有自己可见和克隆


# [Git Git中的按目录权限](https://geek-docs.com/git/git-questions/46_git_perdirectory_permissions_on_git.html)

# Git Git中的按目录权限

在本文中，我们将介绍如何在Git中实现按目录的权限控制。Git是一个分布式版本控制系统，用于协同开发和管理代码。它提供了灵活的权限管理机制，让团队能够限制或允许用户对特定目录的访问和操作。

**阅读更多：[Git 教程](https://geek-docs.com/git)**

## Git中的权限控制

Git中的权限控制是通过访问控制列表（Access Control List，ACL）来实现的。ACL定义了用户或用户组对特定目录的权限。在Git的仓库中，每个目录都有自己的ACL。通过配置ACL，可以限制用户对特定目录的读写权限，或者限制对敏感文件的访问。

## 配置目录的ACL

要配置目录的ACL，首先需要创建一个 `.gitattributes`文件，用于定义目录的ACL规则。该文件位于Git仓库根目录或特定目录下，并且会被Git自动处理。在 `.gitattributes`文件中，可以定义用户或用户组，并为其指定读写权限。

以下是一个 `.gitattributes`文件的示例：

```bash
# .gitattributes

/secret/** group=admin rw
/code/dev/** user=john rw
```

Bash

Copy

上面的示例中，`/secret/**`目录只对属于 `admin`用户组的成员可读可写。而 `/code/dev/**`目录对 `john`用户具有读写权限。

在这个示例中，`**`通配符表示匹配目录下的所有子目录和文件。可以根据需要定义更复杂的目录结构和权限规则。

## 应用目录的ACL

一旦配置了目录的ACL，Git会根据ACL规则自动应用权限。当用户对目录进行操作时，Git会检查用户的权限并相应地控制访问。

以下是一些常见的Git操作及其受ACL控制的示例：

* clone：当用户使用 `<a href="https://geek-docs.com/git/git-top-articles/1000100_git_index.html" data-internallinksmanager029f6b8e52c="22" title="Git 教程" target="_blank" rel="noopener">git</a><span> </span>clone`命令克隆仓库时，Git会根据用户的ACL规则控制克隆的目录的权限。
* push：当用户使用 `<a href="https://geek-docs.com/git/git-top-articles/1000100_git_index.html" data-internallinksmanager029f6b8e52c="22" title="Git 教程" target="_blank" rel="noopener">git</a><span> </span>push`命令将本地修改推送到远程仓库时，Git会检查目录的ACL规则，确保用户具有足够的权限。
* pull：当用户使用 `git pull`命令从远程仓库获取更新时，Git会根据ACL规则控制已更新的文件的权限。

通过配置目录的ACL，团队可以实现对不同用户或用户组的细粒度权限控制，提高代码的安全性和可管理性。

## 总结

在本文中，我们介绍了Git中实现按目录的权限控制的方法。通过配置目录的ACL，团队可以限制或允许特定用户对目录的访问和操作。这在多人协作和敏感项目中非常有用。使用Git的权限控制机制，可以提高代码的安全性和可管理性，确保只有具有相应权限的用户才能进行特定操作。
